
<!DOCTYPE html>
<html>


<head>
<title> Visualizing snake </title>
</head>


<body>

<div class="panel">
<canvas id="canvas" width="600" height="600" style="position:relative; top:50px; left:50px"></canvas>
</div>

<script>

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
 
boardx = 10;
boardy = 10;
cellS = 40;
windx = 600;
windy = 600;
marginx = (windx - boardx * cellS) / 2
marginy = (windy - boardy * cellS) / 2
border = 5
snakeWidth = 20
appleSize = 20
textSize = 20

framesPerMove = 7

dir = [[0,1], [1,0], [0,-1], [-1,0]];

pi = Math.PI;

space = "#fff"
cLine = "#000"
cShade = "#eee"
cSnake = "#00f"
cApple = "#f00"
cText = "#000"

TIME_LIMIT = 1000

function randint(max){
    return Math.floor(Math.random()*max)
}

class Environment{
    constructor(){
        this.timer = 0
        this.score = 0;
        this.actionType = 0;
        this.snakeSize = 2;
        this.headx = boardx/2;
        this.heady = 2;
        this.tailx = this.headx;
        this.taily = 1;

        this.snake = []
        for(var i=0; i<boardx; i++){
            this.snake[i] = []
            for(var j=0; j<boardy; j++){
                this.snake[i][j] = -1;
            }
        }
        this.snake[this.headx][this.heady] = 4;
        this.snake[this.tailx][this.taily] = 0;
        this.applex = 0;
        this.appley = 0;
    }

    agentAction(actionIndex){
        this.timer ++
        var newHeadx = this.headx + dir[actionIndex][0];
        var newHeady = this.heady + dir[actionIndex][1];
        this.snake[this.headx][this.heady] = actionIndex;
        this.headx = newHeadx;
        this.heady = newHeady;
        this.snake[newHeadx][newHeady] = 4;

        if(this.headx == this.applex && this.heady == this.appley){
            this.score += 1;
            //score += 1 - timer*0.5/maxTime;
            this.snakeSize++;
            this.actionType = 1;
        }
        else{
            var tailDir = this.snake[this.tailx][this.taily];
            this.snake[this.tailx][this.taily] = -1;
            this.tailx += dir[tailDir][0];
            this.taily += dir[tailDir][1];
        }
    }

    chanceAction(actionIndex){
        this.applex = Math.floor(actionIndex / boardy);
        this.appley = actionIndex % boardy;
        this.actionType = 0
    }

    validAgentAction(d){
        var newHeadx = this.headx + dir[d][0];
        var newHeady = this.heady + dir[d][1];
        if(newHeadx == -1 || newHeadx == boardx){
            return false;
        }
        if(newHeady == -1 || newHeady == boardy){
            return false;
        }
        return this.snake[newHeadx][newHeady] == -1;
    }

    randomChanceAction(){
        while(true){
            this.applex = randint(boardx)
            this.appley = randint(boardy)
            if(this.snake[this.applex][this.appley] == -1){
                break
            }
        }
        this.actionType = 0
    }
}

env = new Environment();

//Agent game:
actions = [73,1,1,0,78,0,0,0,0,0,11,3,2,2,3,2,3,2,3,3,2,3,2,2,38,3,0,0,1,0,1,0,0,0,1,97,2,1,1,1,1,0,1,2,1,18,0,3,3,3,3,2,2,3,2,3,0,0,63,1,1,2,2,2,1,2,1,2,1,2,60,2,2,2,28,3,0,0,0,0,0,0,3,0,0,3,82,2,2,2,1,1,1,2,1,1,1,2,49,3,3,3,3,0,0,0,0,1,0,0,0,88,1,1,1,1,1,2,2,3,0,0,5,3,3,3,3,3,3,2,2,2,3,12,2,2,2,2,1,0,55,0,0,0,1,1,1,80,1,2,2,2,2,1,1,2,50,3,73,3,3,0,0,0,0,0,1,2,1,1,1,2,26,1,0,0,3,3,3,3,3,3,63,2,2,2,1,1,1,1,42,3,3,41,2,92,1,1,1,0,0,1,2,2,1,0,86,0,0,0,3,2,38,3,0,3,3,3,0,3,1,2,2,3,3,2,2,2,2,2,3,5,2,1,1,0,1,0,1,1,1,0,3,3,3,0,0,0,3,0,3,2,2,3,2,2,3,0,0,3,96,0,1,1,0,1,1,1,2,1,1,1,2,8,2,2,3,3,2,2,2,3,3,3,3,3,3,0,3,0,0,0,0,1,1,0,0,3,2,34,2,2,2,1,1,2,3,3,2,54,1,1,62,2,2,1,31,2,3,3,0,0,2,2,23,3,0,0,59,0,0,0,0,3,0,1,1,36,2,3,3,2,46,57,0,40,2,1,1,2,2,2,2,3,3,2,1,1,1,2,3,32,0,0,3,68,3,0,1,0,3,0,0,0,0,3,0,2,1,0,1,2,3,93,1,2,1,1,2,3,3,2,1,1,7,2,3,0,2,3,0,3,2,3,3,3,0,3,3,0,0,0,0,24,2,2,2,64,0,0,1,1,0,0,1,2,2,2,1,18,1,1,1,2,2,2,3,3,3,3,3,3,0,0,0,3,3,0,0,0,1,2,3,72,1,1,0,2,2,2,1,2,2,2,2,1,1,79,0,3,0,1,0,3,3,0,2,0,16,1,2,2,2,2,2,2,2,2,3,3,3,3,3,0,0,0,0,0,3,3,0,42,0,1,2,1,1,3,1,3,19,2,0,0,1,0,3,0,0,3,3,3,3,3,0,72,1,2,0,2,2,2,2,2,2,2,3,5,3,3,0,0,0,0,3,2,3,0,3,0,96,1,1,1,1,2,2,2,2,0,0,0,0,3,3,3,0,0,1,1,1,1,0,1,1,1,2,2,87,2,2,3,0,0,3,0,1,73,2,1,3,1,0,2,3,2,3,3,3,3,31,1,1,1,12,0,3,3,5,3,1,0,3,82,0,3,3,0,0,1,1,1,2,1,0,2,2,2,3,91,0,3,3,2,1,2,1,2,1,1,68,3,0,0,3,2,3,0,1,3,3,2,2,1,0,3,0,0,0,0,1,1,1,1,0,2,36,2,3,3,2,3,77,0,0,3,1,3,1,1,1,0,1,0,99,1,0,3,33,3,3,3,3,3,3,3,50,1,2,2,2,41,3,0,82,0,3,3,3,0,3,1,2,2,3,10,2,1,3,1,3,3,2,2,3,3,3,42,3,1,1,1,1,43,0,33,3,83,2,0,0,3,3,0,2,2,2,2,0,2,2,1,1,59,3,0,3,0,0,78,1,2,67,3,86,2,2,0,97,0,0,0,61,3,3,3,2,12,2,3,3,3,3,0,1,51,2,1,1,43,0,90,3,2]

env.chanceAction(actions[0])
currAction = actions[1]
currActionIndex = 2
tick = 0


/*
//Manual game:
currAction = 0
tick = -1
env.randomChanceAction()
*/

console.log(env)


function fillRect(color,sx,sy,l,w){
    ctx.fillStyle = color;
    ctx.fillRect(sx,sy,l,w);
}

function drawLine(color,p1x,p1y,p2x,p2y, width){
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(p1x,p1y);
    ctx.lineTo(p2x,p2y);
    ctx.stroke();
}

function fillCirc(color,x,y,r){
    ctx.beginPath();
    ctx.arc(x,y,r,0,2*pi);
    ctx.fillStyle = color;
    ctx.fill();
}

function fillText(text,color,size,x,y){
    ctx.font = String(size)+"px Arial";
    ctx.fillStyle = color;
    ctx.textAlign = "center";
    ctx.fillText(text,x,y);
}

document.addEventListener("keydown",keyHandler);
document.addEventListener("click",clickHandler);

keyMove = ["ArrowRight","ArrowDown","ArrowLeft","ArrowUp"]

function keyHandler(event){
    key = event.code
    event.preventDefault()
    for(i=0; i<4; i++){
		if(keyMove[i] == key){
            if(env.timer != TIME_LIMIT && env.validAgentAction(i)){
                currAction = i
                tick = 0
            }
		}
	}
}

function clickHandler(event){
    rect = canvas.getBoundingClientRect();
    x = event.clientX - rect.left;
    y = event.clientY - rect.top;
}

function draw(){
    fillRect(space, 0, 0, windx, windy)
    fillRect(cLine, marginx - border, marginy - border, boardx*cellS + 2*border, boardy*cellS + 2*border)
    fillRect(space, marginx, marginy, boardx*cellS, boardy*cellS)
    for(var i = 0; i < boardx; i++){
        for(var j = 0; j < boardy; j++){
            if((i + j) % 2 == 0){
                fillRect(cShade, marginx + j * cellS, marginy + i * cellS, cellS, cellS)
            }
        }
    }
    fillCirc(cApple, marginx + env.appley*cellS + cellS/2, marginy + env.applex*cellS + cellS/2, appleSize/2)
    for(i = 0; i < boardx; i++){
        for(j = 0; j < boardy; j++){
            type = env.snake[i][j]
            if(type != -1){
                centerx = marginx + j*cellS + cellS/2
                centery = marginy + i*cellS + cellS/2
                slideProp = tick / framesPerMove
                if(i == env.tailx && j == env.taily && (env.headx + dir[currAction][0] != env.applex || env.heady + dir[currAction][1] != env.appley)){
                    nextx = centerx + dir[type][1] * cellS * slideProp
                    nexty = centery + dir[type][0] * cellS * slideProp
                    fillCirc(cSnake, nextx, nexty, snakeWidth / 2)
                    drawLine(cSnake, nextx, nexty, centerx + dir[type][1] * cellS, centery + dir[type][0] * cellS, snakeWidth)
                }
                else{
                    fillCirc(cSnake, centerx, centery, snakeWidth / 2)
                    if(type == 4){
                        nextDir = dir[currAction]
                        nextx = centerx + nextDir[1] * cellS * (tick / framesPerMove)
                        nexty = centery + nextDir[0] * cellS * (tick / framesPerMove)
                        drawLine(cSnake, centerx, centery, nextx, nexty, snakeWidth)
                        fillCirc(cSnake, nextx, nexty, snakeWidth / 2)
                    }
                    else{
                        drawLine(cSnake, centerx, centery, centerx + dir[type][1] * cellS, centery + dir[type][0] * cellS, snakeWidth)
                    }
                }
            }
        }
    }
    fillText("Score: " + env.score.toString(), cText, textSize, windx/2, marginy/2)
    fillText("Timer: " + env.timer.toString(), cText, textSize, windx/2, marginy/2 + textSize * 1.5)
}

endState = false

function update(){
    if(endState) return
    draw()
    tick++
    if(tick >= framesPerMove){
        tick = 0

        env.agentAction(currAction)
        if(env.actionType == 1){
            env.chanceAction(actions[currActionIndex])
            currActionIndex++
        }
        if(env.timer == TIME_LIMIT){
            endState = true
            return
        }

        // Check if there is only one valid action
        numValidActions = 0
        validAction = -1
        for(i = 0; i < 4; i++){
            if(env.validAgentAction(i)){
                numValidActions++
                validAction = i
            }
        }
        if(numValidActions == 0){
            endState = true
            return
        }
        if(numValidActions == 1){
            currAction = validAction
        }
        else{
            currAction = actions[currActionIndex]
            currActionIndex++
        }
    }
}

function updateManual(){
    draw()
    if(tick == -1){
        
    }
    else if(tick < framesPerMove){
        tick++
    }
    else{
        env.agentAction(currAction)
        tick = -1
        if(env.actionType == 1){
            env.randomChanceAction()
        }
    }
}

var ONE_FRAME_TIME = 1000 / 60 ;
var mainloop = function() {
    update()
    //updateManual()
};
setInterval( mainloop, ONE_FRAME_TIME );

</script>

</body>

</html>
